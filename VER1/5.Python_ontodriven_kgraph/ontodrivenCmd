
CALL apoc.periodic.truncate({ dropSchema: true });

// ========================================
// LUNG CANCER KNOWLEDGE GRAPH - COMPLETE GUIDE
// ========================================

// ========================================
// STEP 1: INSTALL DEPENDENCIES
// ========================================

pip install rdflib pandas pyshacl


// ========================================
// STEP 2: GENERATE RDF DATA
// ========================================

python lung_cancer_etl_engine.py

// Output files:
// - ouput/lung_cancer_instances_out.ttl
// - ouput/auto_generated.cypher


// ========================================
// STEP 3: VALIDATE DATA WITH SHACL (PYTHON)
// ========================================

python validate_shacl.py

// This validates:
// - Data completeness and quality
// - Constraint compliance
// - Relationship integrity
// Output: ouput/shacl_validation_report.txt


// ========================================
// STEP 4: RUN SPARQL QUERIES (PYTHON)
// ========================================

python run_sparql_queries.py

// Executes sample SPARQL queries:
// - List patients
// - Filter by stage
// - Treatment outcomes
// - Biomarker analysis
// See: SPARQL_CYPHER_QUERIES.md


// ========================================
// STEP 5: NEO4J IMPORT (Run in Neo4j Browser)
// ========================================

// Clear existing data
CALL apoc.periodic.truncate({ dropSchema: true });

CREATE CONSTRAINT n10s_unique_uri FOR (r:Resource)
  REQUIRE r.uri IS UNIQUE;

// Initialize n10s - CRITICAL: Use "MAP" for relationships!
CALL n10s.graphconfig.init({
  handleVocabUris: "MAP",           // ✅ NOT "IGNORE"!
  handleMultival: "OVERWRITE",
  handleRDFTypes: "LABELS",
  applyNeo4jNaming: true,
  keepLangTag: false,
  keepCustomDataTypes: false
});

// Import SCHEMA first (for class hierarchy & property definitions)
CALL n10s.rdf.import.fetch(
  "file:///H:/akash/git/CoherencePLM/version26/experiments/GraphDBExperiments/VER1/5.Python_ontodriven_kgraph/ttl_shacl_data/lung_cancer_kg_schema.ttl",
  "Turtle"
);

// Import INSTANCES (patients, treatments, etc.)
// This creates the actual relationships between entities
CALL n10s.rdf.import.fetch(
  "file:///H:/akash/git/CoherencePLM/version26/experiments/GraphDBExperiments/VER1/5.Python_ontodriven_kgraph/ouput/lung_cancer_instances_out.ttl",
  "Turtle"
);

// Verify relationships were created (should see actual relationship types, not ObjectProperty nodes)
MATCH (p:Patient)-[r]->(t)
RETURN type(r) AS RelationshipType, count(*) AS Count
ORDER BY Count DESC LIMIT 10;

// OR Import from GitHub
// CALL n10s.rdf.import.fetch(
//   "https://raw.githubusercontent.com/lavishlyinspired/GraphDBExperiments/refs/heads/main/VER1/5.Python_ontodriven_kgraph/ttl_shacl_data/lung_cancer_kg_schema.ttl",
//   "Turtle"
// );
//
// CALL n10s.rdf.import.fetch(
//   "https://raw.githubusercontent.com/lavishlyinspired/GraphDBExperiments/refs/heads/main/VER1/5.Python_ontodriven_kgraph/ouput/lung_cancer_instances_out.ttl",
//   "Turtle"
// );

// ========================================
// 4. VERIFY ALL 13 RELATIONSHIPS
// ========================================

// List all relationship types (should show 13)
CALL db.relationshipTypes() YIELD relationshipType
WHERE relationshipType STARTS WITH 'ns0__'
RETURN relationshipType
ORDER BY relationshipType;

// Expected results (all 13 relationships):
// 1.  ns0__diagnosedWith
// 2.  ns0__hasGene
// 3.  ns0__hasHistology
// 4.  ns0__hasMutation
// 5.  ns0__hasOutcome
// 6.  ns0__hasStage
// 7.  ns0__hasTumor
// 8.  ns0__receivedTherapy
// 9.  ns0__recommends
// 10. ns0__testedForBiomarker
// 11. ns0__triggers
// 12. ns0__underwentTest
// 13. ns0__usesDrug

// Count each relationship type
MATCH ()-[r]->()
WHERE type(r) STARTS WITH 'ns0__'
RETURN type(r) AS RelationshipType, count(r) AS Count
ORDER BY Count DESC;

// Verify NO ObjectProperty nodes exist (common error!)
MATCH (n:ObjectProperty)
RETURN n.name LIMIT 10;
// Should return: "no rows" ✅

// ========================================
// 5. VERIFY IMPORT SUCCESS
// ========================================

// Check all relationship types
MATCH ()-[r]->()
RETURN type(r) AS RelationshipType, count(r) AS Count
ORDER BY Count DESC;

// Expected relationships:
// - ns0__receivedTherapy
// - ns0__usesDrug
// - ns0__testedForBiomarker
// - ns0__hasStage
// - ns0__hasHistology
// - ns0__hasTumor
// - ns0__hasOutcome

// Count nodes by type
MATCH (n)
RETURN labels(n) AS NodeLabels, count(n) AS Count
ORDER BY Count DESC;

// Visualize schema
CALL db.schema.visualization();

// View sample patient with relationships
MATCH path = (p:ns0__Patient)-[*1..2]->(connected)
WHERE p.ns0__patientId = "P001"
RETURN path
LIMIT 50;

// ========================================
// STEP 6: SHACL VALIDATION IN NEO4J
// ========================================

// Import SHACL shapes
CALL n10s.validation.shacl.import.inline(
"@prefix lc: <http://example.org/lungCancer#> .
@prefix sh: <http://www.w3.org/ns/shacl#> .
@prefix neo4j: <neo4j://graph.schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

#################################################
# Patient
#################################################

lc:PatientShape a sh:NodeShape ;
  sh:targetClass neo4j:Patient ;

  sh:property [
    sh:path neo4j:name ;
    sh:datatype xsd:string ;
    sh:minCount 1 ;
  ] ;

  sh:property [
    sh:path neo4j:age ;
    sh:datatype xsd:integer ;
    sh:minInclusive 0 ;
    sh:maxInclusive 120 ;
  ] ;

  sh:property [
    sh:path neo4j:hasDiagnosis ;
    sh:minCount 1 ;
  ] ;

  sh:property [
    sh:path neo4j:hasSymptom ;
    sh:minCount 1 ;
  ] .

#################################################
# LungCancer
#################################################

lc:LungCancerShape a sh:NodeShape ;
  sh:targetClass neo4j:LungCancer ;

  sh:property [
    sh:path neo4j:hasStage ;
    sh:minCount 1 ;
  ] ;

  sh:property [
    sh:path neo4j:hasType ;
    sh:minCount 1 ;
  ] .

#################################################
# Treatment
#################################################

lc:TreatmentShape a sh:NodeShape ;
  sh:targetClass neo4j:Treatment ;

  sh:property [
    sh:path neo4j:name ;
    sh:minCount 1 ;
  ] .

#################################################
# Article
#################################################

lc:ArticleShape a sh:NodeShape ;
  sh:targetClass neo4j:Article ;

  sh:property [
    sh:path neo4j:title ;
    sh:minCount 1 ;
  ] ;

  sh:property [
    sh:path neo4j:uri ;
    sh:minCount 1 ;
  ] .
",
  "Turtle"
);

// Validate the graph
CALL n10s.validation.shacl.validate()
YIELD focusNode, nodeType, resultMessage, severity
RETURN n10s.rdf.getIRILocalName(severity) AS Severity,
       count(*) AS Count
ORDER BY Severity;

// Get detailed violations
CALL n10s.validation.shacl.validate()
YIELD focusNode, resultMessage, severity, offendingValue
WHERE severity = 'http://www.w3.org/ns/shacl#Violation'
RETURN n10s.rdf.getIRILocalName(focusNode) AS Node,
       resultMessage AS Error,
       offendingValue AS InvalidValue
LIMIT 20;

// See NEO4J_SHACL_VALIDATION.md for more details


// ========================================
// STEP 7: EXAMPLE CYPHER QUERIES
// ========================================

// Q1: All patients with age and stage
MATCH (p:ns0__Patient)-[:ns0__hasStage]->(s:ns0__Stage)
RETURN p.rdfs__label AS Patient,
       p.ns0__age AS Age,
       s.rdfs__label AS Stage
ORDER BY p.ns0__age;

// Q2: Treatment outcomes
MATCH (p:ns0__Patient)-[:ns0__receivedTherapy]->(t:ns0__Therapy)-[:ns0__usesDrug]->(d:ns0__Drug),
      (p)-[:ns0__hasOutcome]->(o:ns0__Outcome)
RETURN p.rdfs__label AS Patient,
       d.rdfs__label AS Drug,
       o.rdfs__label AS Outcome;

// Q3: Biomarker distribution
MATCH (p:ns0__Patient)-[:ns0__testedForBiomarker]->(b:ns0__Biomarker)
RETURN b.rdfs__label AS Biomarker,
       count(p) AS PatientCount
ORDER BY PatientCount DESC;

// Q4: EGFR+ patients
MATCH (p:ns0__Patient)-[:ns0__testedForBiomarker]->(b:ns0__Biomarker),
      (p)-[:ns0__receivedTherapy]->(t:ns0__Therapy)-[:ns0__usesDrug]->(d:ns0__Drug)
WHERE b.rdfs__label CONTAINS "EGFR"
RETURN p.rdfs__label AS Patient,
       p.ns0__age AS Age,
       d.rdfs__label AS Drug;

// See SPARQL_CYPHER_QUERIES.md for SPARQL equivalents


// ========================================
// STEP 8: OPTIONAL CLEANUP
// ========================================

// Add simplified name property
MATCH (n)
WHERE n.uri IS NOT NULL
SET n.name = last(split(n.uri, '/'));

// Remove Resource label if not needed
MATCH (n:Resource)
REMOVE n:Resource;


// ========================================
// 6. MAGIC QUERY - EXPORT DATA
// ========================================

// Define category relationships
MERGE (from:_Category {name:"CancerPatient"})
MERGE (to:_Category {name:"Gene"})
MERGE (from)<-[:_from]-(r:_Relationship {name:"hasGene"})-[:_to]->(to);

// Apply category labels to nodes based on relationships
MATCH (from:_Category)<-[:_from]-(r:_Relationship)-[:_to]->(to:_Category)
MATCH (x)-[rel]->(y)
WHERE type(rel) = r.name
CALL apoc.create.addLabels(x,[from.name]) YIELD node AS xs
CALL apoc.create.addLabels(y,[to.name]) YIELD node AS ys
RETURN count(xs) + count(ys) AS nodesUpdated;



// ========================================
// Export Graph
// ========================================

// Export entire graph to JSON
CALL apoc.export.json.all("lung_cancer_graph.json", {});

// Export specific subgraph
MATCH path = (p:ns0__Patient)-[*1..3]->(connected)
WITH collect(path) AS paths
CALL apoc.export.json.data(
  apoc.coll.toSet(apoc.coll.flatten([p IN paths | nodes(p)])),
  apoc.coll.toSet(apoc.coll.flatten([p IN paths | relationships(p)])),
  "patient_subgraph.json",
  {}
)
YIELD file, nodes, relationships
RETURN file, nodes, relationships;

//  test******************************

MATCH (n:Resource)
REMOVE n:Resource;

// Complete patient graph (P001)
MATCH path = (p:Patient {name: "Patient_P004"})-[*1..3]->(connected)
RETURN path;



final magic query to add category labels based on relationships. This allows for easier querying and visualization by category (e.g., CancerPatient, Gene, Drug).

MATCH (r:ObjectProperty)-[:DOMAIN]->(from:Class)
MATCH (r)-[:RANGE]->(to:Class)
WITH r, from, to,
     toUpper(last(split(r.uri,"#"))) AS relType
MATCH (x)-[rel]->(y)
WHERE type(rel) = relType
RETURN last(split(x.name,"#")),
       " is a " + last(split(from.name,"#")),
       last(split(y.name,"#")),
       " is a " + last(split(to.name,"#"))
LIMIT 20;


or 

MATCH (r:ObjectProperty)-[:DOMAIN]->(from:Class)
MATCH (r)-[:RANGE]->(to:Class)
WITH r, from, to,
     toUpper(replace(r.label,' ','') ) AS relType
MATCH (x)-[rel]->(y)
WHERE type(rel) = relType
RETURN x.label AS subject,
       " is a " + from.label AS subjectType,
       y.label AS object,
       " is a " + to.label AS objectType
LIMIT 20;




run till here and then check the troubleshooting steps below if relationships are missing.

// ========================================
// TROUBLESHOOTING - Relationships Not Showing
// ========================================

// 1. Check current n10s configuration
CALL n10s.graphconfig.show();
// ⚠️ If handleVocabUris is "IGNORE", relationships won't be created!

// 2. Drop and reinitialize with correct config
CALL n10s.graphconfig.drop();

CALL n10s.graphconfig.init({
  handleVocabUris: "MAP",        // ✅ MUST be "MAP" not "IGNORE"
  handleMultival: "ARRAY",
  handleRDFTypes: "LABELS",
  applyNeo4jNaming: true
});

// 3. Clear old data
CALL apoc.periodic.truncate({ dropSchema: true });

// 4. Re-import with correct config
// ... run import queries from above ...


// ========================================
// TROUBLESHOOTING
// ========================================

// PROBLEM: Seeing ObjectProperty nodes instead of relationships?
// 
// Run this to check:
MATCH (n:ObjectProperty) RETURN n.name LIMIT 10;

// If you see results like "ontology#usesDrug", "ontology#hasStage", etc:
// 
// ROOT CAUSE: The instances TTL file contained schema definitions,
//             creating duplicate schema nodes when you import both files
//
// SOLUTION:
// 1. Run ETL again: python lung_cancer_etl_engine.py
//    (Now fixed - no longer includes schema in instances)
// 2. Clear Neo4j and re-import both files
// 3. Verify relationships with query below

// VERIFY: Should see actual relationship types
MATCH (p:Patient)-[r]->(t)
RETURN type(r) AS RelationshipType, labels(t) AS TargetType, count(*) AS Count
ORDER BY Count DESC LIMIT 15;

// Should see results like:
// receivedTherapy, [Therapy], 45
// testedForBiomarker, [Biomarker], 38
// NOT: ObjectProperty nodes


// ========================================
// EXAMPLE QUERIES TO VERIFY RELATIONSHIPS
// ========================================

// Find all patients with treatments and drugs
MATCH (p:Patient)-[:RECEIVEDTHERAPY]->(t:Therapy)-[:USESDRUG]->(d:Drug)
RETURN p.patientId AS Patient, 
       p.label AS PatientLabel,
       d.label AS Drug
LIMIT 10;

// Find patients by biomarker
MATCH (p:Patient)-[:TESTEDFORBIOMARKER]->(b:Biomarker)
RETURN p.patientId AS Patient,
       b.label AS Biomarker,
       count(p) AS Count;

// Check patient stage relationships
MATCH (p:Patient)-[:HASSTAGE]->(s:Stage)
RETURN s.label AS Stage,
       count(p) AS PatientCount;

// Complete patient graph (P001)
MATCH path = (p:Patient {name: "Patient_P004"})-[*1..3]->(connected)
RETURN path;