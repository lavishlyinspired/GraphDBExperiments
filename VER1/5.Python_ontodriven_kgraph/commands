// ========================================
// LUNG CANCER KNOWLEDGE GRAPH SETUP
// ========================================

// 1. Install Python dependencies
pip install rdflib pandas pyshacl

// 2. Generate instance data
python lung_cancer_etl_engine.py


// ========================================
// 3. NEO4J IMPORT (Run in Neo4j Browser)
// ========================================

// Clear existing data
CALL apoc.periodic.truncate({ dropSchema: true });

CREATE CONSTRAINT n10s_unique_uri FOR (r:Resource)
  REQUIRE r.uri IS UNIQUE;

// Initialize n10s - CRITICAL: Use "MAP" for relationships!
CALL n10s.graphconfig.init({
  handleVocabUris: "MAP",           // ✅ NOT "IGNORE"!
  handleMultival: "ARRAY",
  handleRDFTypes: "LABELS",
  applyNeo4jNaming: true,
  keepLangTag: false,
  keepCustomDataTypes: false
});

// Import from local files
CALL n10s.rdf.import.fetch(
  "file:///H:/akash/git/CoherencePLM/version26/experiments/GraphDBExperiments/VER1/5.Python_ontodriven_kgraph/ttl_shacl_data/lung_cancer_kg_schema.ttl",
  "Turtle"
);

CALL n10s.rdf.import.fetch(
  "file:///H:/akash/git/CoherencePLM/version26/experiments/GraphDBExperiments/VER1/5.Python_ontodriven_kgraph/ouput/lung_cancer_instances_out.ttl",
  "Turtle"
);

// OR Import from GitHub
// CALL n10s.rdf.import.fetch(
//   "https://raw.githubusercontent.com/lavishlyinspired/GraphDBExperiments/refs/heads/main/VER1/5.Python_ontodriven_kgraph/ttl_shacl_data/lung_cancer_kg_schema.ttl",
//   "Turtle"
// );
//
// CALL n10s.rdf.import.fetch(
//   "https://raw.githubusercontent.com/lavishlyinspired/GraphDBExperiments/refs/heads/main/VER1/5.Python_ontodriven_kgraph/ouput/lung_cancer_instances_out.ttl",
//   "Turtle"
// );

// ========================================
// 4. VERIFY IMPORT SUCCESS
// ========================================

// Check all relationship types
MATCH ()-[r]->()
RETURN type(r) AS RelationshipType, count(r) AS Count
ORDER BY Count DESC;

// Expected relationships:
// - ns0__receivedTherapy
// - ns0__usesDrug
// - ns0__testedForBiomarker
// - ns0__hasStage
// - ns0__hasHistology
// - ns0__hasTumor
// - ns0__hasOutcome

// Count nodes by type
MATCH (n)
RETURN labels(n) AS NodeLabels, count(n) AS Count
ORDER BY Count DESC;

// Visualize schema
CALL db.schema.visualization();

// View sample patient with relationships
MATCH path = (p:ns0__Patient)-[*1..2]->(connected)
WHERE p.ns0__patientId = "P001"
RETURN path
LIMIT 50;

// ========================================
// 5. OPTIONAL CLEANUP
// ========================================

// Add simplified name property
MATCH (n)
WHERE n.uri IS NOT NULL
SET n.name = last(split(n.uri, '/'));

// Remove Resource label if not needed
MATCH (n:Resource)
REMOVE n:Resource;


// ========================================
// 6. MAGIC QUERY - EXPORT DATA
// ========================================

// Define category relationships
MERGE (from:_Category {name:"CancerPatient"})
MERGE (to:_Category {name:"LungCancer"})
MERGE (from)<-[:_from]-(r:_Relationship {name:"ns0__diagnosedWith"})-[:_to]->(to);

// Apply category labels to nodes based on relationships
MATCH (from:_Category)<-[:_from]-(r:_Relationship)-[:_to]->(to:_Category)
MATCH (x)-[rel]->(y)
WHERE type(rel) = r.name
CALL apoc.create.addLabels(x,[from.name]) YIELD node AS xs
CALL apoc.create.addLabels(y,[to.name]) YIELD node AS ys
RETURN count(xs) + count(ys) AS nodesUpdated;

// ========================================
// Export Graph
// ========================================

// Export entire graph to JSON
CALL apoc.export.json.all("lung_cancer_graph.json", {});

// Export specific subgraph
MATCH path = (p:ns0__Patient)-[*1..3]->(connected)
WITH collect(path) AS paths
CALL apoc.export.json.data(
  apoc.coll.toSet(apoc.coll.flatten([p IN paths | nodes(p)])),
  apoc.coll.toSet(apoc.coll.flatten([p IN paths | relationships(p)])),
  "patient_subgraph.json",
  {}
)
YIELD file, nodes, relationships
RETURN file, nodes, relationships;



run till here and then check the troubleshooting steps below if relationships are missing.

// ========================================
// TROUBLESHOOTING - Relationships Not Showing
// ========================================

// 1. Check current n10s configuration
CALL n10s.graphconfig.show();
// ⚠️ If handleVocabUris is "IGNORE", relationships won't be created!

// 2. Drop and reinitialize with correct config
CALL n10s.graphconfig.drop();

CALL n10s.graphconfig.init({
  handleVocabUris: "MAP",        // ✅ MUST be "MAP" not "IGNORE"
  handleMultival: "ARRAY",
  handleRDFTypes: "LABELS",
  applyNeo4jNaming: true
});

// 3. Clear old data
CALL apoc.periodic.truncate({ dropSchema: true });

// 4. Re-import with correct config
// ... run import queries from above ...


// ========================================
// EXAMPLE QUERIES TO VERIFY RELATIONSHIPS
// ========================================

// Find all patients with treatments and drugs
MATCH (p:ns0__Patient)-[:ns0__receivedTherapy]->(t:ns0__Therapy)-[:ns0__usesDrug]->(d:ns0__Drug)
RETURN p.ns0__patientId AS Patient, 
       p.rdfs__label AS PatientLabel,
       d.rdfs__label AS Drug
LIMIT 10;

// Find patients by biomarker
MATCH (p:ns0__Patient)-[:ns0__testedForBiomarker]->(b:ns0__Biomarker)
RETURN p.ns0__patientId AS Patient,
       b.rdfs__label AS Biomarker,
       count(p) AS Count;

// Check patient stage relationships
MATCH (p:ns0__Patient)-[:ns0__hasStage]->(s:ns0__Stage)
RETURN s.rdfs__label AS Stage,
       count(p) AS PatientCount;

// Complete patient graph (P001)
MATCH path = (p:ns0__Patient {ns0__patientId: "P001"})-[*1..3]->(connected)
RETURN path;